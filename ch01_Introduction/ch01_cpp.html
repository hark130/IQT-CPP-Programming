<h1 id="version-differences">Version Differences</h1>
<hr />
<p>Due to the widespread and common usage of C++ in today's workspace... it is still being updated. Below are some major updates that have been released over the years. C++ 17 is by far the newest release, but we will only be testing up until <strong>C++ 14</strong>.</p>
<h4 id="c-03"><strong>C++ 03</strong></h4>
<h6 id="section">(2003)</h6>
<ul>
<li>Pretty much the same for our purposes</li>
</ul>
<h4 id="c-11">C++ 11</h4>
<h6 id="august-2011">(12 August 2011)</h6>
<ul>
<li>Initializer Lists</li>
<li>Uniform Initialization</li>
<li>Template Aliases</li>
<li>Rvalue References and Move Semantics</li>
<li>Defaulted and Deleted Functions</li>
<li>Variadic Templates</li>
<li>Auto</li>
<li>Inherited Constructors</li>
<li>Decltype Specifier</li>
</ul>
<h4 id="c-14-version-taught-to">C++ 14 (Version Taught To)</h4>
<h6 id="august-2014">(18 August 2014)</h6>
<ul>
<li>Return type deduction for functions</li>
<li>Generic Lambdas</li>
<li>Extended capturing in lambdas</li>
<li>Revised restrictions on Constxpr Functions</li>
<li>Constexpr Variable Templates</li>
</ul>
<h4 id="c-17">C++ 17</h4>
<h6 id="december-2017">(December 2017)</h6>
<ul>
<li>Fold Expressions</li>
<li>If constexpr</li>
<li>Constexpr Lambdas</li>
<li>Template argument deduction for class templates</li>
<li>Filesystem</li>
<li>Parallel STL</li>
<li>Nested Namespaces</li>
<li>Structured Bindings</li>
<li>Cleaner syntax and control flow</li>
</ul>
<h4 id="c-17-changes-guide"><a href="https://stackoverflow.com/questions/38060436/what-are-the-new-features-in-c17">C++ 17 Changes Guide</a></h4>
<hr />
<h1 id="compilers">Compilers</h1>
<hr />
<p>Just like C, C++ has many different compilers. Most of them are compatible with C-programming language as well. Remember, different compilers may have different outcomes. It's a good idea to have a general understanding of each and pick one if you are working in a team.</p>
<h4 id="section-1"></h4>
<h4 id="msvc---microsoft-visual-c">MSVC - Microsoft Visual C++</h4>
<div class="figure">
<img src="/assets/R6wl9gWl_400x400.jpg" />

</div>
<ul>
<li>This is your Visual Studio compiler that we have been using on Windows up until now for C</li>
</ul>
<h4 id="g---gnu-c-compiler">G++ - GNU C++ Compiler</h4>
<div class="figure">
<img src="/assets/GNU_Compiler_Collection_logo.png" />

</div>
<ul>
<li>Similar commands to GCC, as they are both part of the GNU Compiler Collection, just different languages.</li>
</ul>
<h4 id="clang---an-open-source-frontend-part-of-the-llvm-compiler-infrastructure.">CLang - An open-source frontend, part of the LLVM compiler infrastructure.</h4>
<div class="figure">
<img src="/assets/clang.png" />

</div>
<ul>
<li>Very popular on Mac OSX and other systems</li>
</ul>
<hr />
<h1 id="headers-and-source">Headers and Source</h1>
<hr />
<h4 id="all-of-your-knowledge-from-c-translated-to-c"><strong>All of your knowledge from C translated to C++:</strong></h4>
<ul>
<li>Put exported functionality in header (.h) files</li>
<li><em>#include</em> imported functionality from other headers</li>
<li>Put implementation details in source files (<strong>.cpp</strong> now, not <strong>.c</strong>)</li>
<li>Do not use the <strong>#using</strong> directive in a header (we will cover this later)</li>
</ul>
<hr />
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> CyberMissile { 
    <span class="dt">double</span> velocity, position; 
    <span class="dt">double</span> time_to_target_at(<span class="dt">double</span> target_position){
        <span class="kw">return</span> (target_position – position)/velocity;
    }
};</code></pre></div>
<h6 id="you-can-opt-to-put-the-entire-function-definition-in-a-header-file.">You can opt to put the entire function definition in a header file.</h6>
<hr />
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// cybermissile.h </span>

<span class="kw">struct</span> CyberMissile {
    <span class="dt">double</span> velocity, position;
    <span class="dt">double</span> time_to_target_at(<span class="dt">double</span> target_position);
};


<span class="co">// cybermissile.cpp</span>

<span class="dt">double</span> CyberMissile::time_to_target_at(<span class="dt">double</span> target_position){
    <span class="kw">return</span> (target_position – position) / velocity;
}</code></pre></div>
<h6 id="or-we-can-split-the-declaration-and-definition-into-header-and-source-files.">Or we can split the declaration and definition into header and source files.</h6>
<hr />
<h1 id="returning-c-types">Returning C Types</h1>
<hr />
<p><strong>All the primitive data types we learned previously in C are still available in </strong><code>std::arithmetic</code>** including:**</p>
<ul>
<li>(signed) char, unsigned char</li>
<li>int, unsigned int</li>
<li>short, unsigned short</li>
<li>long, unsigned long</li>
<li>float, double, long double</li>
<li>void</li>
<li>nullptr</li>
</ul>
<p><strong>We also see the return of the user-defined data types:</strong></p>
<ul>
<li>structs</li>
<li>unions (will go over)</li>
<li>enum (will go over)</li>
</ul>
<h2 id="and-the-return-of-the-dreaded-pointer"><strong>And the return of the dreaded</strong> *<em><strong>pointer</strong></em></h2>
<div class="figure">
<img src="/assets/C_Data_Users_DefApps_AppData_INTERNETEXPLORER_Temp_Saved_Images_You-shall-deal-with-it.jpg" />

</div>
<p><strong>.....along with some new features that help deal with pointers.</strong></p>
<hr />
<h1 id="c-and-machine-architecture">C++ and Machine Architecture</h1>
<hr />
<h4 id="section-2"><img src="/assets/428660_3029335645707_1032311811_32960633_102660332_n.jpg" /></h4>
<h4 id="the-four-main-types-of-machine-architecture"><strong>The four main types of machine architecture</strong></h4>
<p><strong>32-bit systems:</strong></p>
<ul>
<li><strong>LP32</strong> or <strong>2/4/4</strong> (<em>int</em> is <strong>16-bit</strong> , <em>long</em> and <em>pointer</em> are <strong>32-bit</strong>) - Win16 API</li>
<li><strong>ILP32</strong> or <strong>4/4/4</strong> (<em>int</em>, <em>long</em>, and <em>pointer</em> are <strong>32-bit</strong>) - Win32 and UNIX</li>
</ul>
<p><strong>64-bit systems:</strong></p>
<ul>
<li><strong>LLP64</strong> or <strong>4/4/8</strong> (<em>int</em> and <em>long</em> are <strong>32-bit</strong>, <em>pointer</em> is <strong>64-bit</strong>) - Win64 API</li>
<li><strong>LP64</strong> or <strong>4/8/8</strong> (<em>int</em> is <strong>32-bit</strong>, <em>long</em> and <em>pointer</em> are <strong>64-bit</strong>) - UNIX</li>
</ul>
<p><strong>C++ works for all these architectures</strong></p>
<hr />
<h1 id="c-type-sizes">C++ Type Sizes</h1>
<hr />
<h3 id="integer-type-sizes">Integer Type Sizes</h3>
<p><strong>If you want guaranteed type sizes include:</strong></p>
<pre><code>&lt;cstdint&gt;</code></pre>
<p><strong>This header provides the following types:</strong></p>
<ul>
<li>uint32_t</li>
<li>uint8_t</li>
<li>int64_t</li>
<li>uintfast16_t</li>
</ul>
<h3 id="floating-point-type-sizes">Floating point Type Sizes</h3>
<p><strong>Float</strong> - single precision. Usually IEEE-754 32-bit floating point type.</p>
<p><strong>Double</strong> - double precision. Usually IEEE-754 64-bit floating point type.</p>
<p><strong>Long Double</strong> - extended precision.</p>
<ul>
<li>Doesn't have to map to an IEEE-754 type.</li>
<li>Usually 80-bit x87 floating point type on x86-64 machines.</li>
</ul>
<hr />
<h4 id="documentation"><a href="http://en.cppreference.com/w/cpp/header/cstdint">Documentation</a></h4>
<h2 id="integer-literals">Integer Literals</h2>
<hr />
<p><strong>Some of the integer literals are carry-overs from C. Some are unique to newer C++ standards:</strong></p>
<h4 id="prefix">Prefix</h4>
<ul>
<li><strong>Decimal (base 10):</strong> 12345</li>
<li><strong>Octal (base 8):</strong> 034532</li>
<li><strong>Hex (base 16):</strong> 0xDEADBEEF</li>
<li><strong>Binary (base 2):</strong> 0b1110010101101 <strong>(C++ 14)</strong></li>
</ul>
<h4 id="suffix">Suffix</h4>
<ul>
<li><strong>Unsigned int:</strong> u or U (i.e. 0xDEADBEEFU or 12345u)</li>
<li><strong>Long int:</strong> l or L (i.e. 0xDEADBEEFL)</li>
<li><strong>Unsigned long int:</strong> ul or UL</li>
<li><strong>Long-Long int:</strong> ll or LL <strong>(C++ 11)</strong></li>
<li><strong>Unsigned long-long int:</strong> ull or ULL</li>
</ul>
<hr />
<h2 id="floating-point-literals">Floating Point Literals</h2>
<hr />
<p><strong>Digit-sequence:</strong> Whole number without a decimal separator, exponent is not optional.</p>
<blockquote>
<p>1e10, 1e-5L ...</p>
</blockquote>
<p><strong>Digit-sequence:</strong> Representing a whole number with a decimal separator, in this case the exponent is optional.</p>
<blockquote>
<p>1.e-1, 1.07 ...</p>
</blockquote>
<p><strong>Digit-sequence:</strong> Representing a fractional number. The exponent is optional.</p>
<blockquote>
<p>3.14, .1f, 1.42e100 ...</p>
</blockquote>
<p><strong>Hex-digit-sequence:</strong> representing a whole number without a radix separator. The exponent is never optional for hexadecimal floating-point literals</p>
<blockquote>
<p>0x1ffp10, 0X1ffp-1 ...</p>
</blockquote>
<p><strong>Hex-digit-sequence:</strong> representing a whole number with a radix separator. (The exponent is never optional for hexadecimal floating-point literals.)</p>
<blockquote>
<p>0x0.12fp-1, 0x1p.10 ...</p>
</blockquote>
<p><strong>Hex-digit-sequence:</strong> representing a fractional number with a radix separator.</p>
<blockquote>
<p>0x0.123-1, 0xa.bp10l ...</p>
</blockquote>
<p><strong>Suffix:</strong></p>
<ul>
<li>e | E: The exponent syntax for a decimal floating-point literal.</li>
<li>p | P: The exponent syntax for hexadecimal floating-point literal.</li>
<li>(no suffix) defines <strong>double</strong></li>
<li>f | F: defines <strong>float</strong></li>
<li>l | L: defines <strong>long double</strong></li>
</ul>
<hr />
<h1 id="character-literals">Character Literals</h1>
<hr />
<p><strong>'c-char':</strong> char</p>
<p><strong>u8'c-char':</strong> UTF-8 char</p>
<p><strong>u'c-char':</strong> UCS-2 character- char16_t</p>
<p><strong>U'c-char':</strong> UCS-4 character- char32_t</p>
<p><strong>L'c-char':</strong> wide-character- implementation-defined .</p>
<p><strong>'c-char-sequence':</strong> Can be combined with the above pre-fixes.</p>
<hr />
<h1 id="string-literals">String Literals</h1>
<hr />
<p><strong>Mostly the same as character literals:</strong></p>
<ul>
<li>&quot;unescaped or escape characters&quot;</li>
<li>L&quot;unescaped or escaped characters&quot;</li>
<li>u8&quot;unescaped or escaped characters&quot;</li>
<li>u&quot;unescaped or escaped characters&quot;</li>
<li>U&quot;unescaped or escaped characters&quot;</li>
<li>R&quot;delimiter(raw characters) delimiter&quot;</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//Raw String Examples</span>
<span class="kw">auto</span> str = R”foo(“this is a raw string”/”I (can) use all kinds of ‘characters’”)foo”;</code></pre></div>
<hr />
<h1 id="escape-sequences">Escape Sequences</h1>
<hr />
<p>You have used some of these previously in C. Here is a more comprehensive list:</p>
<ul>
<li>’ : single quote</li>
<li>” : double quote</li>
<li>? : question mark</li>
<li>\ : backslash</li>
<li>: audible bell</li>
<li>: backspace</li>
<li>: form feed</li>
<li>: new line</li>
<li>: carriage return</li>
<li>: horizontal tab</li>
<li> vertical tab</li>
<li>: arbitrary octal value</li>
<li>: arbitrary hex value</li>
<li>: universal character name</li>
</ul>
<hr />
<h1 id="new-c-nullptr">New C++ nullptr</h1>
<hr />
<p>The keyword<code>nullptr</code>denotes the pointer literal. It is a <a href="http://en.cppreference.com/w/cpp/language/value_category">prvalue</a> of type <a href="http://en.cppreference.com/w/cpp/types/nullptr_t">std::nullptr_t</a>. There exist <a href="http://en.cppreference.com/w/cpp/language/implicit_cast">implicit conversions</a> from<code>nullptr</code>to null pointer value of any pointer type and any pointer to member type. Similar conversions exist for any null pointer constant, which includes values of type <a href="http://en.cppreference.com/w/cpp/types/nullptr_t">std::nullptr_t</a> as well as the macro <a href="http://en.cppreference.com/w/cpp/types/NULL">NULL</a>.</p>
<p><strong>nullptr</strong> = a literal that represents a null pointer.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> foo(<span class="dt">int</span> a)
{
    <span class="co">// do stuff with a</span>
}

<span class="dt">void</span> foo(<span class="dt">char</span>* a)
{
    <span class="co">//do stuff with a</span>

}

<span class="dt">int</span> main()
{
    foo(<span class="dv">0</span>);
    foo(NULL);
    foo(<span class="kw">nullptr</span>);
}</code></pre></div>
<p><strong>Which version of foo() gets called each time?</strong><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p><a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/nullptr">https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/nullptr</a></p>
<h1 id="namespaces">Namespaces</h1>
<hr />
<ul>
<li>Recall the topic of scope and local variables from C</li>
<li>As C++ libraries begin to grow, name collisions could occur as your program could include multiple entities that define the same name.</li>
<li>keyword namespace gives a new level of scope, so entities can be defined to a scope.</li>
<li><strong>::</strong> is the scope resolution operator, so you can reference a variable or function in a particular scope.</li>
<li>keyword <strong>using</strong> allows your program to use an entire namespace.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//bas.h</span>
<span class="kw">namespace</span> IQTCPP {
    <span class="dt">int</span> foo;
    <span class="kw">class</span> bar;
    <span class="dt">void</span> bas();
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//some_other_file.cpp</span>
<span class="kw">using</span> <span class="kw">namespace</span> IQTCPP;
<span class="kw">using</span> <span class="kw">namespace</span> IQTCPP::bas;

<span class="dt">void</span> do_stuff() {
    foo = <span class="dv">10</span>;
    bar x;
    IQTCPP::bas();
}
…</code></pre></div>
<h3 id="using-namespace-std-bad-practice">using namespace std == BAD PRACTICE</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> <span class="kw">namespace</span> std; <span class="co">// BAD PRACTICE</span></code></pre></div>
<p>We will go over this more to come. But to keep it short, the <strong>std</strong> namespace is where the C++ built in library routines are kept. This is the &quot;standard&quot; namespace. By &quot;using&quot; the entire standard namespace... we could run into a lot of collisions.</p>
<h1 id="new-to-c">New to C++</h1>
<hr />
<h4 id="we-now-have-auto"><strong>We now have 'auto'</strong></h4>
<h6 id="usage">Usage</h6>
<blockquote>
<p>For variables, specifies that the type of the variable that is being declared will be automatically deduced from its initializer. For functions, specifies that the return type is a trailing return type or will be deduced from its return statements (since C++14) for non-type template parameters, specifies that the type will be deduced from the argument (since C++17).<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
</blockquote>
<p>The <strong>auto</strong> specifier is only allowed for objects declared at block scope (except function parameter lists). It indicates automatic storage duration and no linkage, which are the defaults for these kinds of declarations.</p>
<ul>
<li><strong>auto</strong> lets us specify it once.</li>
<li>variables declared auto will have the compiler try to deduce what the appropriate data type will be</li>
<li>As of C++14, auto can also be used as a function return type. This is useful for working with templates, which we cover later.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="fl">42.0L</span>;

    <span class="co">//code stuffs</span>

    <span class="kw">return</span> (<span class="dv">0</span>);
}</code></pre></div>
<p><strong>auto</strong> can save your life! Or at least your execution:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="dt">int</span> main()
{
    <span class="dt">unsigned</span> <span class="dt">int</span> bad = <span class="dv">-42</span>; <span class="co">// Auto would save us here</span>

    <span class="co">//code stuffs</span>

    <span class="kw">return</span> (<span class="dv">0</span>);
}</code></pre></div>
<hr />
<h4 id="decltype">decltype</h4>
<ul>
<li><strong>decltype</strong> is useful for trying to deduce a data type, but you do not have an initializer.</li>
<li><strong>decltype</strong> extracts the type from another variable.</li>
<li>Both <strong>auto</strong> and <strong>decltype</strong> are very powerful.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> foo = <span class="dv">0</span>;
<span class="kw">decltype</span>(foo) bar; <span class="co">//bar now has the same type as foo</span></code></pre></div>
<p>Decltype and auto ultimately allows devs to focus on logic, rather than mundane tasks.</p>
<hr />
<h4 id="runtime-sized-arrays">Runtime Sized Arrays</h4>
<ul>
<li>New feature to C++14</li>
<li>Arrays can be sized at runtime.</li>
<li>Very similar to C99's VLAs except for a few exceptions which can be found <a href="https://blog.smartbear.com/development/a-glimpse-into-c14/">here</a>.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> fun(<span class="dt">int</span> i)
{
    <span class="dt">int</span> array[i];
}</code></pre></div>
<hr />
<h4 id="functions">Functions</h4>
<p>You can still use C-style functions:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> do_stuff(<span class="dt">int</span> in_param, <span class="dt">char</span>[] array, <span class="dt">double</span> *out_param)</code></pre></div>
<p>Major improvements:</p>
<ul>
<li>Passing with <strong>references</strong>.</li>
<li>Passing <strong>structs/classes</strong> by value.</li>
<li><strong>const</strong> parameters.</li>
</ul>
<hr />
<h4 id="default-argument-values">Default Argument Values</h4>
<p>You can make arguments optional by giving them default values:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> function_with_default(<span class="dt">double</span> x=<span class="dv">100</span>)
{
    <span class="kw">return</span> x;
}

<span class="kw">auto</span> a = function_with_default();         <span class="co">// What is returned?</span>
<span class="kw">auto</span> b = function_with_default(<span class="dv">42</span>);       <span class="co">// What is returned?</span></code></pre></div>
<hr />
<h4 id="const">const</h4>
<p>New keyword, means you wont change the value of the <strong>const</strong> variable.</p>
<p>It is a <strong>const</strong>ant.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main()
{
    <span class="dt">const</span> <span class="kw">auto</span> x = <span class="dv">100</span>;
    x = <span class="dv">200</span>;     <span class="co">//Does not compile</span>
    <span class="co">//code stuffs</span>
    <span class="kw">return</span> (<span class="dv">0</span>);
}</code></pre></div>
<p><strong>const</strong> variables cannot be modified. This includes <strong>const</strong> pointers.</p>
<p><strong>const int</strong> * <strong><em>ptr</em></strong>- a pointer that points to constant data.</p>
<ul>
<li>You can modify the pointer itself.. but not the object &quot;data&quot; pointed to by the ptr</li>
</ul>
<p><strong>int* const</strong> <em>ptr</em>- a pointer that cannot be reassigned.</p>
<ul>
<li>You cannot modify the pointer itself... but you can modify the object &quot;data&quot; pointed to by the ptr</li>
</ul>
<p><strong>const int* const</strong> - a pointer that is constant, that points to data that is constant.</p>
<ul>
<li>You cannot modify the pointer nor the object &quot;data&quot; the pointer points to.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> a = <span class="bn">0xDEADBEEF</span>;
<span class="dt">const</span> <span class="dt">int</span> b = <span class="bn">0xCAFEF00D</span>;
<span class="dt">int</span>* <span class="dt">const</span> ptr1 = &amp;a;    <span class="co">//ERROR</span>
<span class="dt">const</span> <span class="dt">int</span>* ptr2 = &amp;a;
ptr2 = &amp;b;
<span class="dt">const</span> <span class="dt">int</span>* <span class="dt">const</span> ptr3 = &amp;a;
ptr3 = &amp;b    <span class="co">//ERROR</span></code></pre></div>
<hr />
<p><a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> : <a href="http://en.cppreference.com/w/cpp/language/auto">CPP Source</a></p>
<h1 id="passing-const">Passing const</h1>
<hr />
<p>You can pass by reference/pointer/value with or without the <strong>'const'</strong> qualifier:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> distance_def(<span class="dt">const</span> Point &amp;point){
    <span class="kw">return</span> sqrt(point.x * point.x + point.y * point.y);
};
…</code></pre></div>
<p>What's wrong with the following function declaration?</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> calculate_stuff(<span class="dt">const</span> Point point);</code></pre></div>
<hr />
<h1 id="passing-by-value">Passing by value</h1>
<hr />
<p>You can pass structs (and classes) by value:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> distance(Point point){
    point.x *= point.x;
    point.y *= point.y;
    <span class="kw">return</span> sqrt(point.x + point.y);
};
…</code></pre></div>
<hr />
<h1 id="references">References</h1>
<hr />
<h4 id="lets-take-a-look-at-references...">Lets take a look at references...</h4>
<p>A reference can be thought of as a constant pointer <em>(not to be confused with a pointer to a constant value or constant reference)</em> with automatic indirection, i.e. the compiler will apply the <strong>*</strong> operator for you. The caller just passes the object, giving us a layer of transparency. (Again, don't worry too much about this yet. These are OOP concepts.)</p>
<p>References are pointers that cannot be null; meaning the called function does not have to check for null values. References also allow you to interact with the variable without having to use the dereference operator.</p>
<p>A reference variable is an alias, that is, another name for an already existing variable. A reference, like a pointer is also implemented by storing the address of an object.</p>
<ul>
<li>References can be assigned only once</li>
<li>References will always refer to an initialized object</li>
<li>You cannot obtain the address of a reference</li>
<li>There is no such thing as reference arithmetic</li>
<li>References are easier to use, giving you less chances of bugs</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Point{
    <span class="dt">int</span> x, y;
};

voidset_to_origin(Point &amp;point){
    point.x = <span class="dv">0</span>;
    point.y = <span class="dv">0</span>;
}
…</code></pre></div>
<hr />
<h4 id="how-does-it-compare-to-pointers">How does it compare to pointers?</h4>
<p>A pointer is a variable that holds the memory address of another variable. A pointer needs to be dereferenced with <strong>*</strong> operator to access the memory location it points to.</p>
<ul>
<li>Pointers can be reassigned any number of times</li>
<li>Pointers can point to nothing</li>
<li>You can obtain the address of a pointer</li>
<li>Pointer arithmetic is a real thing</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Point{
    <span class="dt">int</span> x, y;
};

<span class="dt">void</span> set_to_origin(Point *point){
    point-&gt;x = <span class="dv">0</span>;
    point-&gt;y = <span class="dv">0</span>;
}
…</code></pre></div>
<hr />
<h2 id="function-design-guidelines">Function Design Guidelines</h2>
<ul>
<li>Pass by <strong>const reference</strong> when you want to pass in an argument that will not be modified.</li>
<li>Pass by <strong>reference</strong> when you want to pass an argument that can be modified</li>
<li>Pass by value when you want a copy that you can modify.</li>
<li>Never use raw pointers unless:
<ul>
<li>We are using <em>C-Functions</em></li>
<li>You want to ability to use 0 value or NULL arguments.</li>
</ul></li>
</ul>
<h6 id="note-consider-whether-you-must-operate-on-const-arguments-e.g.-from-an-external-api">Note: consider whether you must operate on <strong>const</strong> arguments e.g. from an external API</h6>
<h3 id="proceed-to-lab-1a">Proceed to lab 1A</h3>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>It all depends on the type being passed in. More on this later.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>It all depends on the type being passed in. More on this later.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>It all depends on the type being passed in. More on this later.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
